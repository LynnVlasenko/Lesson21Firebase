//
//  DatabaseService.swift
//  Lesson21Firebase
//
//  Created by Алина Власенко on 04.04.2023.
//
// Сервіс  для роботи з Firebase та надає доступ для роботи з даними (їх отримання та додавання до БД)

import Foundation
import Firebase

final class DatabaseService {
    
    // 4. Якщо буде багато референсів, можна створити енум шляхів
    private enum Path {
        static let cats = "Cats"
    }
    
    // 1. зробимо наш клас сінглтоном (також можна робити через інджекшн - в контроллері інджектити його, але ми робимо окремо від вью контроллерів. Також це дає можливість працювати з даними з різних вью контролерів - просто створюючи об'єкт нашого класу всередині контроллера - і звертатись до його вмісту)
    static let shared = DatabaseService()
    
    // 2. щоб не могли створювати нових об'єктів
    private init() {}
    
     // 3. отримуємо посилання на root reference
    let rootRef = Database.database(url: "https://lesson21-d017b-default-rtdb.firebaseio.com/").reference()
     
    // 5. створюємо референс на модель котів, вказавши шлях, з енума (це є посилання на об'єкт масиву котів)
    let catsRef = Database.database().reference(withPath: Path.cats)
    
    // 6. Створимо котів. Створюємо метод, який буде додавати нових котів
    func addNewCat(cat: Cat) {
        //створюємо референс на одного кота
        let catRef = catsRef.childByAutoId()
        
        //сетимо значення у вигляді dictionary - вказуючи ключ та значення з моделі даних колтів
        catRef.setValue([
            "name": cat.name,
            "age": cat.age
        ])
    }
    
    // 7. Створюємо зчитування для відображення даних на екрані, коли перезайдемо у застосунок.
    //створюємо метод з комплішином - комплішн це є @escaping кложура, яка має time життя довше ніж сама функція. Бо функція виконується і видаляється, а коли ми позначаємо її @escaping - це значить. шо ця кложура буде жити довше і вона зсоже виконатися, навіть, коли функція вже не існує(тобто вже її не має в пам'яті). Тобто ми подовжуємо життя кложури, яка виконається пізніше.
    func getCats(completion: @escaping ([Cat]) -> ()) {
        //створемо масив наших котів, які будть результатом роботи функції. Порожній масив буде наповнюватися даними з БД, коли вони витягнуться.
        var result = [Cat]()
        
        //далі по референсу котів, який створили вище, будемо обзервити(слухати) .value, тобто будь-які зміни в БД(додавання - видалення, зміна даних і т.д. - але можна обзервити і конкретні - окремо додавання, видалення або зміну і т.д.(.childAdded, .childChanged..)), далі with - це є кложура(коли тиснемо ентер на ній - створюється трейлінг кложура - закривається дужка за .value і в фігурних лапках через in прописуємо кложуру - вказуємо снапшот - знімок інформації в конкретний момент часу)
        catsRef.observeSingleEvent(of: .value) { snapshot in
            //тут ми проходимося по чайлдах і беремо кодного чілдрена нашого референсу котів(тобто кожного кота). Тобто child треба привесті до кота, щоб ми могли зчитувати інформацію про нього.
            for child in snapshot.children {
                if let catSnapshot = child as?  DataSnapshot,
                   // для того, щоб зробиит з child та snapshot нашого кота, нам потрібно додати новий ініціалізатор(який буде ініціалізувати нашого кота із снапшота), для цього потрібно зайти в нашу модель котів(в наш клас у вью контроллері) і створити в цьому класі ініціалізатор обов'язковий і ініт через снапшот)
                   //ініціалізуємо нашого кота через ініціалізатор снпшоту, який прописали у моделі
                   let cat = Cat(snapshot: catSnapshot) {
                    //і якщо ми змогли створити нашого кота, то ми можемо додавати його до резалт масиву
                    result.append(cat)
                }
            }
            completion(result) //обов'язково викликаємо комплішн місля циклу, щоб повернути отримані дані.
        }
    }
}
